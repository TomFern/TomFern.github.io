<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Benchmarking with sysbench | Chaos is order undeciphered</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Benchmarking with sysbench" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A getting started guide to benchmarking with sysbench" />
<meta property="og:description" content="A getting started guide to benchmarking with sysbench" />
<link rel="canonical" href="https://tomfern.com/post/sysbench-guide-1" />
<meta property="og:url" content="https://tomfern.com/post/sysbench-guide-1" />
<meta property="og:site_name" content="Chaos is order undeciphered" />
<meta property="og:image" content="https://tomfern.com/images/database.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-09T00:05:00-03:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://tomfern.com/images/database.jpg" />
<meta property="twitter:title" content="Benchmarking with sysbench" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-01-09T00:05:00-03:00","datePublished":"2019-01-09T00:05:00-03:00","description":"A getting started guide to benchmarking with sysbench","headline":"Benchmarking with sysbench","image":"https://tomfern.com/images/database.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://tomfern.com/post/sysbench-guide-1"},"url":"https://tomfern.com/post/sysbench-guide-1"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://tomfern.com/feed.xml" title="Chaos is order undeciphered" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Chaos is order undeciphered</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/images/">Shared static images</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Benchmarking with sysbench</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-01-09T00:05:00-03:00" itemprop="datePublished">Jan 9, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="/images/database.jpg" alt="" /></p>

<h2 id="why-when-how">Why, When, How?</h2>

<p>Benchmark shows the difference between should and does. Coupled with <a href="../tag/monitoring">monitoring</a> it’s a great tool to identify bottlenecks.</p>

<p>As to when: whenever we can, as long as the system is production. A good benchmark will stress the server so we don’t want users affected.
Right after provisioning a server, during a maintenance window, before and after any major changes, these are all good opportunities to take advantage of a few precious
minutes of calm to run some tests.</p>

<p>We should try to mimic as best as possible the behaviour of the software we have.
Is it single or multithreaded? Is it on more CPU bound or disk IO bound. Does it access data randomly or sequentially?
Does it manage data on fixed-size blocks?</p>

<h2 id="introducing-sysbench">Introducing Sysbench</h2>

<p>Sysbench is a popular benchmark tool that is available for linux, mac and can even run on windows (with it’s subsystem for linux).
It ships with tests for the OS and databases. It is extensible and scriptable, so writing our own tests is possible.</p>

<p>If you are running linux, it’s most likely available in your distribution repository. Otherwise head to sysbench’s <a href="https://github.com/akopytov/sysbench">github</a> for instructions.</p>

<h2 id="getting-started">Getting Started</h2>

<p>The general syntax is:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysbench &lt;testname&gt; &lt;action&gt; <span class="o">[</span>test-specific options]
</code></pre></div></div>

<p>Sysbench has quite a few options, but help a few keystrokes away. To get to the general help:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysbench <span class="nt">--help</span>
</code></pre></div></div>

<p>And for the specific test use:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysbench &lt;testname&gt; <span class="nb">help</span>
</code></pre></div></div>

<p>Some tests have a <em>prepare</em> and <em>cleanup</em> action, some also have an optional <em>warmup</em> action, others can be <em>run</em> directly.</p>

<h2 id="the-test-loop">The Test Loop</h2>

<p>All tests have a common structure, the requested number of worker threads are created, each one will run its own test loop,
each iteration of the loop is called an <em>event</em> and can have any number of operations. Sysbench keeps counters on all events across all threads.</p>

<p>When it’s done, we get the statistics for all events. Under <em>latency</em> we can see the average event duration.
These values are common to all tests.</p>

<pre><code class="language-nil">...
General statistics:
    total time:                          10.0014s
    total number of events:              32479

Latency (ms):
         min:                                    1.11
         avg:                                    2.46
         max:                                   41.95
         95th percentile:                       11.24
         sum:                                79934.27

Threads fairness:
    events (avg/stddev):           4059.8750/59.44
    execution time (avg/stddev):   9.9918/0.01
</code></pre>

<p>On multithreaded tests we want that events are distributed fairly among all threads, i.e. all threads should execute approximately the same number of events.
This is shown under <em>fairness</em>, the <em>stddev</em> (standard deviation) should be small in relation to the <em>average</em>.</p>

<p>Most of the benchmarks will run for a specified time or until a certain condition is met. The default time limit is 10 seconds, but we can
change that using <code class="language-plaintext highlighter-rouge">--time</code>. Alternatively we can set a limit number of <code class="language-plaintext highlighter-rouge">--events</code>.</p>

<h2 id="testing-your-cpus">Testing Your CPUs</h2>

<p>In this first test we’ll torture the CPUs by computing prime numbers.
Each single event will check prime numbers up to the provided <code class="language-plaintext highlighter-rouge">--cpu-max-prime</code>.
The higher this value is, the longer it takes an event to end.</p>

<p>I usually like to start with single threadetest. I try to find a <code class="language-plaintext highlighter-rouge">--cpu-max-prime</code> that will take at least a few seconds to complete.</p>

<pre><code class="language-nil"># sysbench cpu test, single event
-&gt; sysbench cpu run --threads=1 --events=1 --cpu-max-prime=8000000
sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Prime numbers limit: 8000000

Initializing worker threads...

Threads started!

CPU speed:
    events per second:     0.09

General statistics:
    total time:                          11.2315s
    total number of events:              1

Latency (ms):
         min:                                11231.45
         avg:                                11231.45
         max:                                11231.45
         95th percentile:                    11317.84
         sum:                                11231.45

Threads fairness:
    events (avg/stddev):           1.0000/0.00
    execution time (avg/stddev):   11.2314/0.00
</code></pre>

<p>With a suitable max prime number found, the next step is to run a longer test.</p>

<pre><code class="language-nil"># sysbench cpu, single thread
-&gt; sysbench cpu run --threads=1 --time=60 --cpu-max-prime=8000000
sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Prime numbers limit: 8000000

Initializing worker threads...

Threads started!

CPU speed:
    events per second:     0.09

General statistics:
    total time:                          67.5691s
    total number of events:              6

Latency (ms):
         min:                                11217.78
         avg:                                11261.48
         max:                                11302.15
         95th percentile:                    11317.84
         sum:                                67568.87

Threads fairness:
    events (avg/stddev):           6.0000/0.00
    execution time (avg/stddev):   67.5689/0.00
</code></pre>

<p>On <em>average</em>, it took 11.261 seconds to calculate primes up to our limit.
A lower average is better, since it means the CPU takes less time to reach the same point. For the same reason, a higher value in <em>events per second</em> is better.</p>

<p>If we are going to run multithreaded applications we need to run another test with an appropiate number <code class="language-plaintext highlighter-rouge">--threads</code>.
For example in a system with 4 cores with hyperthreading this is a good starting point.</p>

<pre><code class="language-nil"># cpu test, 8 threads
-&gt; sysbench cpu run --threads=8 --time=60 --cpu-max-prime=8000000
sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 8
Initializing random number generator from current time


Prime numbers limit: 8000000

Initializing worker threads...

Threads started!

CPU speed:
    events per second:     0.29

General statistics:
    total time:                          82.1154s
    total number of events:              24

Latency (ms):
         min:                                26514.20
         avg:                                27212.58
         max:                                28103.35
         95th percentile:                    27846.48
         sum:                               653101.88

Threads fairness:
    events (avg/stddev):           3.0000/0.00
    execution time (avg/stddev):   81.6377/0.36
</code></pre>

<h2 id="testing-your-memory">Testing Your Memory</h2>

<p>For memory we can test either <em>write</em> or <em>read</em> speeds, the mode is selected with <code class="language-plaintext highlighter-rouge">--memory-open</code>.
We can choose between sequential (<em>seq</em>) and random (<em>rnd</em>) access modes with <code class="language-plaintext highlighter-rouge">--memory-access-mode</code>.</p>

<p>This benchmark has a special stop condition: <code class="language-plaintext highlighter-rouge">--memory-total-size</code>. Bear in mind, this isn’t the total size allocated in RAM.</p>

<pre><code class="language-nil"># memory, no time limit, stop on 100GB written
-&gt; sysbench memory run --memory-total-size=100G --memory-open=write --memory-access-mode=rnd --time=0
WARNING: Both event and time limits are disabled, running an endless test
sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Running memory speed test with the following options:
  block size: 1KiB
  total size: 102400MiB
  operation: write
  scope: global

Initializing worker threads...

Threads started!

Total operations: 104857600 (5010197.95 per second)

102400.00 MiB transferred (4892.77 MiB/sec)


General statistics:
    total time:                          20.9272s
    total number of events:              104857600

Latency (ms):
         min:                                    0.00
         avg:                                    0.00
         max:                                    0.38
         95th percentile:                        0.00
         sum:                                10816.80

Threads fairness:
    events (avg/stddev):           104857600.0000/0.00
    execution time (avg/stddev):   10.8168/0.00
</code></pre>

<p>The latency is measured in milliseconds, it’s just to big of a unit for memory speeds so it’s not very useful here.
But we can think of the <em>MiB per seconds</em> as the average speed.</p>

<p>If we have a service that work with fixed-size blocks, for example if plan to have a database,
we should set <code class="language-plaintext highlighter-rouge">--memory-block-size</code> to match it.</p>

<pre><code class="language-nil"># some memory tests for MySQL (page size is 16K)
sysbench memory run --threads=8 --memory-block-size=16K --memory-total-size=100G --memory-oper=write
sysbench memory run --threads=8 --memory-block-size=16K --memory-total-size=100G --memory-oper=read
</code></pre>

<h2 id="testing-your-disk-io-speed">Testing Your Disk I/O Speed</h2>

<p>Before starting, we need to <em>prepare</em> a file or set of files to work on. We set the <strong>total</strong> space to allocate with <code class="language-plaintext highlighter-rouge">--file-total-size</code> (which must be at least 2GB)
and how many files there will be in the set, the space will be split into even sized files.</p>

<p>We probably want to avoid caching the files in memory because we wouldn’t be measuring the true disk spee,
 so it might me a good idea to include <code class="language-plaintext highlighter-rouge">--file-extra-flags=direct</code> to bypass it.</p>

<p>It’s generally recommended, whenever possible, that allocated space is larger than the installed RAM, just in case caching is taking place in spite of our best efforts.</p>

<pre><code class="language-nil">-&gt; sysbench fileio prepare --file-num=10 --file-total-size=10G --file-extra-flags=direct

sysbench 1.0.15 (using system LuaJIT 2.0.5)

10 files, 1048576Kb each, 10240Mb total
Creating files for the test...
Extra file open flags: (none)
Creating file test_file.0
Creating file test_file.1
Creating file test_file.2
Creating file test_file.3
Creating file test_file.4
Creating file test_file.5
Creating file test_file.6
Creating file test_file.7
Creating file test_file.8
Creating file test_file.9
10737418240 bytes written in 45.15 seconds (226.78 MiB/sec).
</code></pre>

<blockquote>
  <p><em>prepare</em> can reutilize previous test files, but it only can <strong>grow</strong> them, so we can only reuse test files if they are bigger or equal than before. Otherwise we must <em>cleanup</em> and <em>prepare</em> again.</p>
</blockquote>

<p>Now we need to choose a <code class="language-plaintext highlighter-rouge">--file-test-mode</code>:</p>

<ul>
  <li>seqwr: sequential write</li>
  <li>seqrewr: sequential read+write</li>
  <li>seqrd: sequential read</li>
  <li>rndrd: random read</li>
  <li>rndwr: random write</li>
  <li>rndrw: random read write</li>
</ul>

<pre><code class="language-nil"># file read-write test
-&gt; sysbench fileio run --file-num=10 --file-total-size=10G --file-test-mode=rndrw --file-extra-flags=direct --time=60

sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Extra file open flags: directio
10 files, 1GiB each
10GiB total file size
Block size 16KiB
Number of IO requests: 0
Read/Write ratio for combined random IO test: 1.50
Periodic FSYNC enabled, calling fsync() each 100 requests.
Calling fsync() at the end of test, Enabled.
Using synchronous I/O mode
Doing random r/w test
Initializing worker threads...

Threads started!


File operations:
    reads/s:                      2388.59
    writes/s:                     1592.38
    fsyncs/s:                     398.14

Throughput:
    read, MiB/s:                  37.32
    written, MiB/s:               24.88

General statistics:
    total time:                          60.0027s
    total number of events:              262756

Latency (ms):
         min:                                    0.06
         avg:                                    0.23
         max:                                   77.63
         95th percentile:                        0.39
         sum:                                59796.75

Threads fairness:
    events (avg/stddev):           262756.0000/0.00
    execution time (avg/stddev):   59.7967/0.00
</code></pre>

<p>As always, it’s a good idea to try to match as best as possible the disk IO activity for our application. We have some flexibility here
with additional options:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">--file-num</code> number of files [128]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-block-size</code> block size [16384]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-total-size</code> total size  [2G]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-test-mode</code> test mode: seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw</li>
  <li><code class="language-plaintext highlighter-rouge">--file-io-mode</code> file operations mode: sync,async,mmap [sync]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-async-backlog</code> number of asynchronous requests per thread [128]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-extra-flags</code> list of additional flags to use to open files: sync,dsync,direct</li>
  <li><code class="language-plaintext highlighter-rouge">--file-fsync-freq</code> fsync() every N requests [100]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-fsync-all</code> fsync() after each write [off]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-fsync-end</code> fsync() at the end of test [on]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-fsync-mode</code> method for sync: fsync, fdatasync [fsync]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-merged-requests</code> max I/O request to merge [0]</li>
  <li><code class="language-plaintext highlighter-rouge">--file-rw-ratio</code> reads/writes ratio for combined test [1.5]</li>
</ul>

<p>As an example, for a system destined to run a MySQL server we could try something like this.</p>

<pre><code class="language-nil"># a test simulating MySQL file activity
sysbench fileio run --threads=8 --file-extra-flags=direct --file-test-mode=rndrw --file-num=10 --file-block-size=1M --file-block-size=16K
</code></pre>

<p>After running our tests, we need only to remove the work files with <em>cleanup</em></p>

<pre><code class="language-nil">-&gt; sysbench fileio cleanup --file-num=10

sysbench 1.0.15 (using system LuaJIT 2.0.5)

Removing test files...
</code></pre>

<h2 id="testing-mutexes">Testing Mutexes</h2>

<p>This benchmark is intended to test the speed for mutex locks (mutex stands for “mutual exclusion”).
Which play an important role in multithreading. It simulates high concurrency, with threads acquiring and releasing locks all the time.</p>

<p>Sysbench creates an initial pool of <code class="language-plaintext highlighter-rouge">--mutex-num</code> mutexes, then it starts the threads, which iterate over an empty loop, every <code class="language-plaintext highlighter-rouge">--mutex-loops</code> the thread will
grab one random mutex from the pool, modify a global variable, and release it. Each event will acquire and release the mutexes until the <code class="language-plaintext highlighter-rouge">--mutex-locks</code> value is reached.</p>

<p>Here <code class="language-plaintext highlighter-rouge">--time</code> or <code class="language-plaintext highlighter-rouge">--events</code> are completely ignored. Sysbench always runs one event per thread.</p>

<pre><code class="language-nil">-&gt; sysbench mutex run --threads=10
sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 10
Initializing random number generator from current time


Initializing worker threads...

Threads started!


General statistics:
    total time:                          0.8845s
    total number of events:              10

Latency (ms):
         min:                                  802.84
         avg:                                  855.55
         max:                                  873.81
         95th percentile:                      877.61
         sum:                                 8555.51

Threads fairness:
    events (avg/stddev):           1.0000/0.00
    execution time (avg/stddev):   0.8556/0.02
</code></pre>

<h2 id="testing-threads">Testing Threads</h2>

<p>Here we have a test for the CPU scheduler. It can simulate high concurrency conditions, where multiple threads
compete for mutexes.</p>

<p>Each thread will take <code class="language-plaintext highlighter-rouge">--thread-locks</code> mutexes and yield the CPU. This causes the thread to stop running and is placed on the run queue by the scheduler.
Once the thread is again scheduled to run, the mutexes are released.</p>

<p>A single event will perform these actions <code class="language-plaintext highlighter-rouge">--thread-yields</code> times, so the higher this number, the higher the concurrency placed on each mutex,
and the lower the number of events per second.</p>

<pre><code class="language-nil">-&gt; sysbench threads run --threads=4 --thread-yields=1000 --thread-locks=10
sysbench 1.0.15 (using system LuaJIT 2.0.5)

Running the test with following options:
Number of threads: 4
Initializing random number generator from current time


Initializing worker threads...

Threads started!


General statistics:
    total time:                          10.0005s
    total number of events:              50754

Latency (ms):
         min:                                    0.50
         avg:                                    0.79
         max:                                   14.37
         95th percentile:                        0.81
         sum:                                39980.48

Threads fairness:
    events (avg/stddev):           12688.5000/54.38
    execution time (avg/stddev):   9.9951/0.00
</code></pre>

<h2 id="related-links">Related Links</h2>

<ul>
  <li>sysbench’s github: <a href="https://github.com/akopytov/sysbench">https://github.com/akopytov/sysbench</a></li>
</ul>

<h2 id="whats-next">What’s Next?</h2>

<p>Whew, that was a longer post than I intended and to think I only covered a part of it all.</p>

<p>There is still more to say about sysbench, check the <a href="./sysbench-guide-2">second part</a> where I deal with databases, so the fun is just starting.</p>

<p>So long.</p>

<p>Tomas</p>

  </div><a class="u-url" href="/post/sysbench-guide-1" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Chaos is order undeciphered</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Chaos is order undeciphered</li><li><a class="u-email" href="mailto:contact (at) tomfern.com">contact (at) tomfern.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/tomfern"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">tomfern</span></a></li><li><a href="https://www.twitter.com/tomfernblog"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">tomfernblog</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Technical writer at Semaphore CI/CD</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
