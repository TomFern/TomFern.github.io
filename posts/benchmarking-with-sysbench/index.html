<!doctype html><html lang=en-us><head><title>Benchmarking with sysbench | Chaos is order not yet deciphered</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="A getting started guide to benchmarking with sysbench"><meta name=generator content="Hugo 0.98.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-169184519-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a>
<a class=button href=/index.xml>RSS</a></nav><main class=main><section id=single><h1 class=title>Benchmarking with sysbench</h1><div class=tip><time datetime="2019-01-09 00:05:00 -0300 -03">Jan 9, 2019</time>
<span class=split>¬∑</span>
<span>2044 words</span>
<span class=split>¬∑</span>
<span>10 minute read</span></div><div class=content><p><p class=markdown-image><img src=/images/database.jpg alt></p></p><h2 id=why-when-how>Why, When, How? <a href=#why-when-how class=anchor>üîó</a></h2><p>Benchmark shows the difference between should and does. Coupled with <a href=../tag/monitoring>monitoring</a> it&rsquo;s a great tool to identify bottlenecks.</p><p>As to when: whenever we can, as long as the system is production. A good benchmark will stress the server so we don&rsquo;t want users affected.
Right after provisioning a server, during a maintenance window, before and after any major changes, these are all good opportunities to take advantage of a few precious
minutes of calm to run some tests.</p><p>We should try to mimic as best as possible the behaviour of the software we have.
Is it single or multithreaded? Is it on more CPU bound or disk IO bound. Does it access data randomly or sequentially?
Does it manage data on fixed-size blocks?</p><h2 id=introducing-sysbench>Introducing Sysbench <a href=#introducing-sysbench class=anchor>üîó</a></h2><p>Sysbench is a popular benchmark tool that is available for linux, mac and can even run on windows (with it&rsquo;s subsystem for linux).
It ships with tests for the OS and databases. It is extensible and scriptable, so writing our own tests is possible.</p><p>If you are running linux, it&rsquo;s most likely available in your distribution repository. Otherwise head to sysbench&rsquo;s <a href=https://github.com/akopytov/sysbench target=_blank rel=noopener>github</a> for instructions.</p><h2 id=getting-started>Getting Started <a href=#getting-started class=anchor>üîó</a></h2><p>The general syntax is:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sysbench &lt;testname&gt; &lt;action&gt; <span style=color:#666>[</span>test-specific options<span style=color:#666>]</span>
</span></span></code></pre></div><p>Sysbench has quite a few options, but help a few keystrokes away. To get to the general help:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sysbench --help
</span></span></code></pre></div><p>And for the specific test use:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sysbench &lt;testname&gt; <span style=color:#a2f>help</span>
</span></span></code></pre></div><p>Some tests have a <em>prepare</em> and <em>cleanup</em> action, some also have an optional <em>warmup</em> action, others can be <em>run</em> directly.</p><h2 id=the-test-loop>The Test Loop <a href=#the-test-loop class=anchor>üîó</a></h2><p>All tests have a common structure, the requested number of worker threads are created, each one will run its own test loop,
each iteration of the loop is called an <em>event</em> and can have any number of operations. Sysbench keeps counters on all events across all threads.</p><p>When it&rsquo;s done, we get the statistics for all events. Under <em>latency</em> we can see the average event duration.
These values are common to all tests.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          10.0014s
</span></span><span style=display:flex><span>    total number of events:              32479
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                    1.11
</span></span><span style=display:flex><span>         avg:                                    2.46
</span></span><span style=display:flex><span>         max:                                   41.95
</span></span><span style=display:flex><span>         95th percentile:                       11.24
</span></span><span style=display:flex><span>         sum:                                79934.27
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           4059.8750/59.44
</span></span><span style=display:flex><span>    execution time (avg/stddev):   9.9918/0.01
</span></span></code></pre></div><p>On multithreaded tests we want that events are distributed fairly among all threads, i.e. all threads should execute approximately the same number of events.
This is shown under <em>fairness</em>, the <em>stddev</em> (standard deviation) should be small in relation to the <em>average</em>.</p><p>Most of the benchmarks will run for a specified time or until a certain condition is met. The default time limit is 10 seconds, but we can
change that using <code>--time</code>. Alternatively we can set a limit number of <code>--events</code>.</p><h2 id=testing-your-cpus>Testing Your CPUs <a href=#testing-your-cpus class=anchor>üîó</a></h2><p>In this first test we&rsquo;ll torture the CPUs by computing prime numbers.
Each single event will check prime numbers up to the provided <code>--cpu-max-prime</code>.
The higher this value is, the longer it takes an event to end.</p><p>I usually like to start with single threadetest. I try to find a <code>--cpu-max-prime</code> that will take at least a few seconds to complete.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># sysbench cpu test, single event
</span></span><span style=display:flex><span>-&gt; sysbench cpu run --threads=1 --events=1 --cpu-max-prime=8000000
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 1
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Prime numbers limit: 8000000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CPU speed:
</span></span><span style=display:flex><span>    events per second:     0.09
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          11.2315s
</span></span><span style=display:flex><span>    total number of events:              1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                11231.45
</span></span><span style=display:flex><span>         avg:                                11231.45
</span></span><span style=display:flex><span>         max:                                11231.45
</span></span><span style=display:flex><span>         95th percentile:                    11317.84
</span></span><span style=display:flex><span>         sum:                                11231.45
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           1.0000/0.00
</span></span><span style=display:flex><span>    execution time (avg/stddev):   11.2314/0.00
</span></span></code></pre></div><p>With a suitable max prime number found, the next step is to run a longer test.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># sysbench cpu, single thread
</span></span><span style=display:flex><span>-&gt; sysbench cpu run --threads=1 --time=60 --cpu-max-prime=8000000
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 1
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Prime numbers limit: 8000000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CPU speed:
</span></span><span style=display:flex><span>    events per second:     0.09
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          67.5691s
</span></span><span style=display:flex><span>    total number of events:              6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                11217.78
</span></span><span style=display:flex><span>         avg:                                11261.48
</span></span><span style=display:flex><span>         max:                                11302.15
</span></span><span style=display:flex><span>         95th percentile:                    11317.84
</span></span><span style=display:flex><span>         sum:                                67568.87
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           6.0000/0.00
</span></span><span style=display:flex><span>    execution time (avg/stddev):   67.5689/0.00
</span></span></code></pre></div><p>On <em>average</em>, it took 11.261 seconds to calculate primes up to our limit.
A lower average is better, since it means the CPU takes less time to reach the same point. For the same reason, a higher value in <em>events per second</em> is better.</p><p>If we are going to run multithreaded applications we need to run another test with an appropiate number <code>--threads</code>.
For example in a system with 4 cores with hyperthreading this is a good starting point.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># cpu test, 8 threads
</span></span><span style=display:flex><span>-&gt; sysbench cpu run --threads=8 --time=60 --cpu-max-prime=8000000
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 8
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Prime numbers limit: 8000000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CPU speed:
</span></span><span style=display:flex><span>    events per second:     0.29
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          82.1154s
</span></span><span style=display:flex><span>    total number of events:              24
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                26514.20
</span></span><span style=display:flex><span>         avg:                                27212.58
</span></span><span style=display:flex><span>         max:                                28103.35
</span></span><span style=display:flex><span>         95th percentile:                    27846.48
</span></span><span style=display:flex><span>         sum:                               653101.88
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           3.0000/0.00
</span></span><span style=display:flex><span>    execution time (avg/stddev):   81.6377/0.36
</span></span></code></pre></div><h2 id=testing-your-memory>Testing Your Memory <a href=#testing-your-memory class=anchor>üîó</a></h2><p>For memory we can test either <em>write</em> or <em>read</em> speeds, the mode is selected with <code>--memory-open</code>.
We can choose between sequential (<em>seq</em>) and random (<em>rnd</em>) access modes with <code>--memory-access-mode</code>.</p><p>This benchmark has a special stop condition: <code>--memory-total-size</code>. Bear in mind, this isn&rsquo;t the total size allocated in RAM.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># memory, no time limit, stop on 100GB written
</span></span><span style=display:flex><span>-&gt; sysbench memory run --memory-total-size=100G --memory-open=write --memory-access-mode=rnd --time=0
</span></span><span style=display:flex><span>WARNING: Both event and time limits are disabled, running an endless test
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 1
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running memory speed test with the following options:
</span></span><span style=display:flex><span>  block size: 1KiB
</span></span><span style=display:flex><span>  total size: 102400MiB
</span></span><span style=display:flex><span>  operation: write
</span></span><span style=display:flex><span>  scope: global
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Total operations: 104857600 (5010197.95 per second)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>102400.00 MiB transferred (4892.77 MiB/sec)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          20.9272s
</span></span><span style=display:flex><span>    total number of events:              104857600
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                    0.00
</span></span><span style=display:flex><span>         avg:                                    0.00
</span></span><span style=display:flex><span>         max:                                    0.38
</span></span><span style=display:flex><span>         95th percentile:                        0.00
</span></span><span style=display:flex><span>         sum:                                10816.80
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           104857600.0000/0.00
</span></span><span style=display:flex><span>    execution time (avg/stddev):   10.8168/0.00
</span></span></code></pre></div><p>The latency is measured in milliseconds, it&rsquo;s just to big of a unit for memory speeds so it&rsquo;s not very useful here.
But we can think of the <em>MiB per seconds</em> as the average speed.</p><p>If we have a service that work with fixed-size blocks, for example if plan to have a database,
we should set <code>--memory-block-size</code> to match it.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># some memory tests for MySQL (page size is 16K)
</span></span><span style=display:flex><span>sysbench memory run --threads=8 --memory-block-size=16K --memory-total-size=100G --memory-oper=write
</span></span><span style=display:flex><span>sysbench memory run --threads=8 --memory-block-size=16K --memory-total-size=100G --memory-oper=read
</span></span></code></pre></div><h2 id=testing-your-disk-io-speed>Testing Your Disk I/O Speed <a href=#testing-your-disk-io-speed class=anchor>üîó</a></h2><p>Before starting, we need to <em>prepare</em> a file or set of files to work on. We set the <strong>total</strong> space to allocate with <code>--file-total-size</code> (which must be at least 2GB)
and how many files there will be in the set, the space will be split into even sized files.</p><p>We probably want to avoid caching the files in memory because we wouldn&rsquo;t be measuring the true disk spee,
so it might me a good idea to include <code>--file-extra-flags=direct</code> to bypass it.</p><p>It&rsquo;s generally recommended, whenever possible, that allocated space is larger than the installed RAM, just in case caching is taking place in spite of our best efforts.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>-&gt; sysbench fileio prepare --file-num=10 --file-total-size=10G --file-extra-flags=direct
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10 files, 1048576Kb each, 10240Mb total
</span></span><span style=display:flex><span>Creating files for the test...
</span></span><span style=display:flex><span>Extra file open flags: (none)
</span></span><span style=display:flex><span>Creating file test_file.0
</span></span><span style=display:flex><span>Creating file test_file.1
</span></span><span style=display:flex><span>Creating file test_file.2
</span></span><span style=display:flex><span>Creating file test_file.3
</span></span><span style=display:flex><span>Creating file test_file.4
</span></span><span style=display:flex><span>Creating file test_file.5
</span></span><span style=display:flex><span>Creating file test_file.6
</span></span><span style=display:flex><span>Creating file test_file.7
</span></span><span style=display:flex><span>Creating file test_file.8
</span></span><span style=display:flex><span>Creating file test_file.9
</span></span><span style=display:flex><span>10737418240 bytes written in 45.15 seconds (226.78 MiB/sec).
</span></span></code></pre></div><blockquote><p><em>prepare</em> can reutilize previous test files, but it only can <strong>grow</strong> them, so we can only reuse test files if they are bigger or equal than before. Otherwise we must <em>cleanup</em> and <em>prepare</em> again.</p></blockquote><p>Now we need to choose a <code>--file-test-mode</code>:</p><ul><li>seqwr: sequential write</li><li>seqrewr: sequential read+write</li><li>seqrd: sequential read</li><li>rndrd: random read</li><li>rndwr: random write</li><li>rndrw: random read write</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># file read-write test
</span></span><span style=display:flex><span>-&gt; sysbench fileio run --file-num=10 --file-total-size=10G --file-test-mode=rndrw --file-extra-flags=direct --time=60
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 1
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Extra file open flags: directio
</span></span><span style=display:flex><span>10 files, 1GiB each
</span></span><span style=display:flex><span>10GiB total file size
</span></span><span style=display:flex><span>Block size 16KiB
</span></span><span style=display:flex><span>Number of IO requests: 0
</span></span><span style=display:flex><span>Read/Write ratio for combined random IO test: 1.50
</span></span><span style=display:flex><span>Periodic FSYNC enabled, calling fsync() each 100 requests.
</span></span><span style=display:flex><span>Calling fsync() at the end of test, Enabled.
</span></span><span style=display:flex><span>Using synchronous I/O mode
</span></span><span style=display:flex><span>Doing random r/w test
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>File operations:
</span></span><span style=display:flex><span>    reads/s:                      2388.59
</span></span><span style=display:flex><span>    writes/s:                     1592.38
</span></span><span style=display:flex><span>    fsyncs/s:                     398.14
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Throughput:
</span></span><span style=display:flex><span>    read, MiB/s:                  37.32
</span></span><span style=display:flex><span>    written, MiB/s:               24.88
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          60.0027s
</span></span><span style=display:flex><span>    total number of events:              262756
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                    0.06
</span></span><span style=display:flex><span>         avg:                                    0.23
</span></span><span style=display:flex><span>         max:                                   77.63
</span></span><span style=display:flex><span>         95th percentile:                        0.39
</span></span><span style=display:flex><span>         sum:                                59796.75
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           262756.0000/0.00
</span></span><span style=display:flex><span>    execution time (avg/stddev):   59.7967/0.00
</span></span></code></pre></div><p>As always, it&rsquo;s a good idea to try to match as best as possible the disk IO activity for our application. We have some flexibility here
with additional options:</p><ul><li><code>--file-num</code> number of files [128]</li><li><code>--file-block-size</code> block size [16384]</li><li><code>--file-total-size</code> total size [2G]</li><li><code>--file-test-mode</code> test mode: seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw</li><li><code>--file-io-mode</code> file operations mode: sync,async,mmap [sync]</li><li><code>--file-async-backlog</code> number of asynchronous requests per thread [128]</li><li><code>--file-extra-flags</code> list of additional flags to use to open files: sync,dsync,direct</li><li><code>--file-fsync-freq</code> fsync() every N requests [100]</li><li><code>--file-fsync-all</code> fsync() after each write [off]</li><li><code>--file-fsync-end</code> fsync() at the end of test [on]</li><li><code>--file-fsync-mode</code> method for sync: fsync, fdatasync [fsync]</li><li><code>--file-merged-requests</code> max I/O request to merge [0]</li><li><code>--file-rw-ratio</code> reads/writes ratio for combined test [1.5]</li></ul><p>As an example, for a system destined to run a MySQL server we could try something like this.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span># a test simulating MySQL file activity
</span></span><span style=display:flex><span>sysbench fileio run --threads=8 --file-extra-flags=direct --file-test-mode=rndrw --file-num=10 --file-block-size=1M --file-block-size=16K
</span></span></code></pre></div><p>After running our tests, we need only to remove the work files with <em>cleanup</em></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>-&gt; sysbench fileio cleanup --file-num=10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Removing test files...
</span></span></code></pre></div><h2 id=testing-mutexes>Testing Mutexes <a href=#testing-mutexes class=anchor>üîó</a></h2><p>This benchmark is intended to test the speed for mutex locks (mutex stands for &ldquo;mutual exclusion&rdquo;).
Which play an important role in multithreading. It simulates high concurrency, with threads acquiring and releasing locks all the time.</p><p>Sysbench creates an initial pool of <code>--mutex-num</code> mutexes, then it starts the threads, which iterate over an empty loop, every <code>--mutex-loops</code> the thread will
grab one random mutex from the pool, modify a global variable, and release it. Each event will acquire and release the mutexes until the <code>--mutex-locks</code> value is reached.</p><p>Here <code>--time</code> or <code>--events</code> are completely ignored. Sysbench always runs one event per thread.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>-&gt; sysbench mutex run --threads=10
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 10
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          0.8845s
</span></span><span style=display:flex><span>    total number of events:              10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                  802.84
</span></span><span style=display:flex><span>         avg:                                  855.55
</span></span><span style=display:flex><span>         max:                                  873.81
</span></span><span style=display:flex><span>         95th percentile:                      877.61
</span></span><span style=display:flex><span>         sum:                                 8555.51
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           1.0000/0.00
</span></span><span style=display:flex><span>    execution time (avg/stddev):   0.8556/0.02
</span></span></code></pre></div><h2 id=testing-threads>Testing Threads <a href=#testing-threads class=anchor>üîó</a></h2><p>Here we have a test for the CPU scheduler. It can simulate high concurrency conditions, where multiple threads
compete for mutexes.</p><p>Each thread will take <code>--thread-locks</code> mutexes and yield the CPU. This causes the thread to stop running and is placed on the run queue by the scheduler.
Once the thread is again scheduled to run, the mutexes are released.</p><p>A single event will perform these actions <code>--thread-yields</code> times, so the higher this number, the higher the concurrency placed on each mutex,
and the lower the number of events per second.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>-&gt; sysbench threads run --threads=4 --thread-yields=1000 --thread-locks=10
</span></span><span style=display:flex><span>sysbench 1.0.15 (using system LuaJIT 2.0.5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Running the test with following options:
</span></span><span style=display:flex><span>Number of threads: 4
</span></span><span style=display:flex><span>Initializing random number generator from current time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Initializing worker threads...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads started!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>General statistics:
</span></span><span style=display:flex><span>    total time:                          10.0005s
</span></span><span style=display:flex><span>    total number of events:              50754
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Latency (ms):
</span></span><span style=display:flex><span>         min:                                    0.50
</span></span><span style=display:flex><span>         avg:                                    0.79
</span></span><span style=display:flex><span>         max:                                   14.37
</span></span><span style=display:flex><span>         95th percentile:                        0.81
</span></span><span style=display:flex><span>         sum:                                39980.48
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Threads fairness:
</span></span><span style=display:flex><span>    events (avg/stddev):           12688.5000/54.38
</span></span><span style=display:flex><span>    execution time (avg/stddev):   9.9951/0.00
</span></span></code></pre></div><h2 id=related-links>Related Links <a href=#related-links class=anchor>üîó</a></h2><ul><li>sysbench&rsquo;s github: <a href=https://github.com/akopytov/sysbench target=_blank rel=noopener>https://github.com/akopytov/sysbench</a></li></ul><h2 id=whats-next>What&rsquo;s Next? <a href=#whats-next class=anchor>üîó</a></h2><p>Whew, that was a longer post than I intended and to think I only covered a part of it all.</p><p>There is still more to say about sysbench, check the <a href=./sysbench-guide-2>second part</a> where I deal with databases, so the fun is just starting.</p><p>So long.</p><p>Tomas</p></div><div class=tags><a href=tags/linux>linux</a>
<a href=tags/unix>unix</a>
<a href=tags/guides>guides</a></div></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/TomFern rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://github.com/TomFernBlog rel=me target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><div class=copyright>¬© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Tommy ‚Äî Technical Writer at Semaphore</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>