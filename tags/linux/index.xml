<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on Chaos is order not yet deciphered</title><link>http://tomfern.com/tags/linux/</link><description>Recent content in linux on Chaos is order not yet deciphered</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Feb 2019 11:21:00 -0300</lastBuildDate><atom:link href="http://tomfern.com/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Making the most out of Docker</title><link>http://tomfern.com/posts/making-the-most-out-of-docker/</link><pubDate>Sat, 02 Feb 2019 11:21:00 -0300</pubDate><guid>http://tomfern.com/posts/making-the-most-out-of-docker/</guid><description>Some options that might increase performance, some that don&amp;rsquo;t.
Network ðŸ”—Containers get connected to a bridge network by default. A software bridge that allows communication between containers running on the same host &amp;amp; bridge. We can also create and use custom bridges, to create isolated groups of containers. To allow connections from outside, we must map the host&amp;rsquo;s ports to a container&amp;rsquo;s with -p (publish e.g. -p 3306:3306) This is easy and flexible, but it makes Docker start an additional process (docker-proxy), which can use a non-trivial amount of CPU.</description></item><item><title>Benchmarking with sysbench</title><link>http://tomfern.com/posts/benchmarking-with-sysbench/</link><pubDate>Wed, 09 Jan 2019 00:05:00 -0300</pubDate><guid>http://tomfern.com/posts/benchmarking-with-sysbench/</guid><description>Why, When, How? ðŸ”—Benchmark shows the difference between should and does. Coupled with monitoring it&amp;rsquo;s a great tool to identify bottlenecks.
As to when: whenever we can, as long as the system is production. A good benchmark will stress the server so we don&amp;rsquo;t want users affected. Right after provisioning a server, during a maintenance window, before and after any major changes, these are all good opportunities to take advantage of a few precious minutes of calm to run some tests.</description></item><item><title>System Monitoring with Sar</title><link>http://tomfern.com/posts/system-monitoring-with-sar/</link><pubDate>Mon, 07 Jan 2019 01:40:00 -0300</pubDate><guid>http://tomfern.com/posts/system-monitoring-with-sar/</guid><description>sar is part of the sysstat project, a suite of programs for system monitoring. With sar, we can log system activity, build performance reports and even make plots.
sar is available on Linux, Solaris, AIX and HP-UX.
We can choose to run sar automatically, as an unattended script. Or interactively and get system metrics on the spot.
Unattended Mode ðŸ”—With a simple cron entry we can log system activity. If possible, as root, otherwise some data may be missing.</description></item><item><title>A guide to vmstat and friends</title><link>http://tomfern.com/posts/a-guide-to-vmstat-and-friends/</link><pubDate>Sun, 06 Jan 2019 21:12:00 -0300</pubDate><guid>http://tomfern.com/posts/a-guide-to-vmstat-and-friends/</guid><description>A getting started guide for vmstat, iostat, mpstat and pidstat.
vmstat ðŸ”—Once I figured out how vmstat works, I found that I almost could no longer live without it, it&amp;rsquo;s that good. Fortunately it&amp;rsquo;s available everywhere, so I don&amp;rsquo;t. There are many versions around, both for Linux and Unix.
vmstat does a little bit of everything: memory, processes, I/O, swap, disks, CPU.
The basic syntax is:
vmstat [options] &amp;lt;interval&amp;gt; &amp;lt;count&amp;gt; vmstat prints a new update every interval seconds, stopping after count lines.</description></item></channel></rss>